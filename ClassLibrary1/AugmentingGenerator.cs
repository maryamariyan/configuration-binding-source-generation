using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace Generators
{
    [Generator]
    public class AugmentingGenerator : ISourceGenerator
    {
        public bool UseGeneric { get; set; } = false;
        public Dictionary<string, Type> TypesToBind { get; private set; }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a factory that can create our custom syntax receiver
            context.RegisterForSyntaxNotifications(() => new MySyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            //if (!System.Diagnostics.Debugger.IsAttached)
            //    System.Diagnostics.Debugger.Launch();
            //System.Diagnostics.Debugger.Break();

            MySyntaxReceiver syntaxReceiver = (MySyntaxReceiver)context.SyntaxReceiver;

            var metadataLoadContext = new MetadataLoadContext(context.Compilation);
            var assembly = metadataLoadContext.MainAssembly;

            if (UseGeneric)
            {
                foreach (var (memberAccess, handlerType) in syntaxReceiver.GenericBindCalls)
                {
                    var semanticModel = context.Compilation.GetSemanticModel(memberAccess.Expression.SyntaxTree);
                    var typeInfo = semanticModel.GetTypeInfo(memberAccess.Expression);

                    semanticModel = context.Compilation.GetSemanticModel(handlerType.SyntaxTree);
                    typeInfo = semanticModel.GetTypeInfo(handlerType);

                    var type = assembly.GetType(typeInfo.Type.ToDisplayString());

                    if (!(TypesToBind ??= new Dictionary<string, Type>()).ContainsKey(type.FullName))
                        TypesToBind[type.FullName] = type;
                }
            }
            else
            {
                foreach ((MemberAccessExpressionSyntax _, ArgumentSyntax ArgSyntax) bindOverload in syntaxReceiver.NonGenericBindCalls)
                {
                    SemanticModel compilationSemanticModel = context.Compilation.GetSemanticModel(bindOverload.ArgSyntax.SyntaxTree);

                    ITypeSymbol typeSymbol = compilationSemanticModel.GetTypeInfo(bindOverload.ArgSyntax.Expression).Type;
                    Type type = new TypeWrapper(typeSymbol, metadataLoadContext);

                    if (!(TypesToBind ??= new Dictionary<string, Type>()).ContainsKey(type.FullName))
                        TypesToBind[type.FullName] = type;
                }
            }

            if (TypesToBind == null)
            {
                return;
            }

            foreach (KeyValuePair<string, Type> pair in TypesToBind)
            {
                Type type = pair.Value;

                StringBuilder sb = new();

                sb.Append(@$"using System;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;

namespace {type.Namespace}
{{
    public static class {type.Name}ConfigurationExensions
    {{
        public static void ShowInfo(this {type.Name} value)
        {{
            Console.WriteLine($""nameof(ShowInfo): Called AutoGenerated Bind API for: {{value.GetType().FullName}}"");
        }}

        public static void Bind(this IConfiguration configuration, string key, {type.Name} instance)
        {{
            Console.WriteLine(""first overload"");
            configuration.GetSection(key).Bind(instance);
        }}

        public static void Bind(this IConfiguration configuration, {type.Name} instance)
        {{
            Console.WriteLine(""second overload"");
            configuration.Bind(instance, o => {{ }});
        }}

        public static void Bind(this IConfiguration configuration, {type.Name} instance, Action<BinderOptions> configureOptions)
        {{
            Console.WriteLine(""third overload"");
            instance.ShowInfo();");

                foreach (PropertyInfo property in type.GetProperties())
                {
                    sb.AppendLine(@$"
            instance.{property.Name} = configuration.GetValue<{property.PropertyType.FullName}>(""{property.Name}"");");

                }

                sb.Append(@"
        }
    }
}
");
                context.AddSource($"{type.Name}.generated.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }
        

        class MySyntaxReceiver : ISyntaxReceiver
        {
            public List<(MemberAccessExpressionSyntax, SeparatedSyntaxList<ArgumentSyntax>)> BindOverloads { get; } = new();
            public List<(MemberAccessExpressionSyntax, ArgumentSyntax)> NonGenericBindCalls { get; } = new();
            public List<(MemberAccessExpressionSyntax, TypeSyntax)> GenericBindCalls { get; } = new();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MemberAccessExpressionSyntax 
                    { 
                        Name: SimpleNameSyntax { Identifier: { ValueText: "Bind" } },
                        Parent: InvocationExpressionSyntax { ArgumentList: { Arguments: { } arguments } }
                    } mapBindCall)
                {
                    // TODO cleanup condition
                    if (arguments.Count == 1)
                    {
                        NonGenericBindCalls.Add((mapBindCall, arguments[0]));
                    }
                    else if (arguments.Count == 2)
                    {
                        if (arguments[1].Expression is SimpleLambdaExpressionSyntax)
                        {
                            // the instance is the first arg for this overload
                            NonGenericBindCalls.Add((mapBindCall, arguments[0]));
                        }
                        else
                        {
                            NonGenericBindCalls.Add((mapBindCall, arguments[1]));
                        }
                    }
                }
            }
        }
    }
}
